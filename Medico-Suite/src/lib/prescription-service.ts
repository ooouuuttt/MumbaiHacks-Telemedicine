
'use client';

import {
  collection,
  addDoc,
  serverTimestamp,
  query,
  where,
  onSnapshot,
  orderBy,
  DocumentData,
  doc,
  updateDoc,
  arrayUnion,
  Timestamp,
  getDocs,
} from 'firebase/firestore';
import { db } from './firebase';
import type { PrescriptionReaderOutput } from '@/ai/flows/prescription-reader';
import { Medication } from './user-service';
import { createNotification } from './notification-service';
import { formatDoctorName } from './utils';


export interface Prescription extends DocumentData {
  id: string;
  createdAt: Timestamp;
  doctorId: string;
  doctorName: string;
  followUp?: string;
  instructions?: string;
  medications: Medication[];
  patientId: string;
  patientName: string;
}


// Fetches prescriptions from the top-level 'prescriptions' collection
export const getPrescriptions = (
  uid: string,
  callback: (prescriptions: Prescription[]) => void
) => {
  const q = query(
    collection(db, 'prescriptions'),
    where('patientId', '==', uid),
    orderBy('createdAt', 'desc')
  );

  let isFirstLoad = true;
  const notifiedPrescriptions = new Set<string>();

  const unsubscribe = onSnapshot(
    q,
    (querySnapshot) => {
      const prescriptions: Prescription[] = [];
      const newlyAdded: Prescription[] = [];
      
      querySnapshot.forEach((doc) => {
        const prescription = { id: doc.id, ...doc.data() } as Prescription;
        prescriptions.push(prescription);

        if (!isFirstLoad && !notifiedPrescriptions.has(doc.id)) {
            newlyAdded.push(prescription);
            notifiedPrescriptions.add(doc.id);
        }
      });
      
      // After first load, notify for newly added prescriptions
      if (!isFirstLoad) {
          newlyAdded.forEach(prescription => {
              createNotification(uid, {
                title: 'New E-Prescription Received',
                description: `You have a new prescription from ${formatDoctorName(prescription.doctorName)}.`,
                type: 'medicine'
              });
          });
      }

      callback(prescriptions);
      isFirstLoad = false;
    },
    (error) => {
      console.error('Error fetching prescriptions:', error);
      callback([]);
    }
  );

  return unsubscribe;
};

// This function saves a scanned prescription into the user's document,
// which is separate from the e-prescriptions generated by doctors.
// This could be refactored to also write to the main 'prescriptions' collection if needed.
export const saveScannedPrescription = async (
  uid: string,
  data: PrescriptionReaderOutput
): Promise<void> => {
  if (!uid || !data) {
    throw new Error('User ID and prescription data are required.');
  }

  const newPrescription = {
    id: `scan_${Date.now()}`,
    date: data.date, // Note: The doctor-generated prescriptions use a Timestamp.
    doctorName: data.doctorName,
    medications: data.medicines.map(med => ({
      name: med.name,
      dosage: med.dosage,
      frequency: med.frequency,
      days: med.duration, // Note: AI flow uses 'duration', schema uses 'days'
    })),
  };

  const userDocRef = doc(db, 'users', uid);
  
  await updateDoc(userDocRef, {
    pastPrescriptions: arrayUnion(newPrescription)
  });
};
